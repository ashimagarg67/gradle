// tag::declare-configuration[]
configurations {
    // Declare two dependency scope configurations, named `implementation` and `runtimeOnly`
    implementation {
        // This configuration is only meant to declare dependencies.
        // It should not be resolved or consumed
        canBeConsumed = false
        canBeResolved = false
    }
    runtimeOnly {
        canBeConsumed = false
        canBeResolved = false
    }
}

dependencies {
    // Declare that our project's API depends on artifacts from the `lib` project
    implementation project(":lib")
    // Declare that our project's implementation depends on artifacts from the `anotherLib` project
    runtimeOnly project(":anotherLib")
}
// end::declare-configuration[]

// tag::resolvable-configurations[]
configurations {
    // Declare two resolvable configurations, named `compileClasspath` and `runtimeClasspath`
    compileClasspath {
        // This configuration is not meant to be consumed and
        // should not allow dependencies to be declared on it
        canBeConsumed = false
        canBeDeclared = false
        extendsFrom(implementation)
    }
    runtimeClasspath {
        canBeConsumed = false
        canBeDeclared = false
        extendsFrom(implementation)
        extendsFrom(runtimeOnly)
    }
}
// end::resolvable-configurations[]

// tag::consumable-configurations[]
configurations {
    // Declare two consumable configurations, named `apiElements` and `runtimeElements`
    apiElements {
        // This configuration is not meant to be resolved and
        // should not allow dependencies to be declared on it
        canBeResolved = false
        canBeDeclared = false
        extendsFrom(implementation)
    }
    runtimeElements {
        canBeResolved = false
        canBeDeclared = false
        extendsFrom(implementation)
        extendsFrom(runtimeOnly)
    }
}
// end::consumable-configurations[]

// tag::define_attribute[]
// An attribute of type `String`
def myAttribute = Attribute.of("my.attribute.name", String)
// An attribute of type `Usage`
def myUsage = Attribute.of("my.usage.attribute", Usage)
// end::define_attribute[]

// tag::register-attributes[]
dependencies.attributesSchema {
    // registers this attribute to the attributes schema
    attribute(myAttribute)
    attribute(myUsage)
}
// end::register-attributes[]

// tag::attributes-on-configurations[]
configurations {
    apiElements {
        attributes {
            attribute(myAttribute, 'my-value')
        }
    }
}
// end::attributes-on-configurations[]

// tag::named-attributes[]
configurations {
    runtimeElements {
        attributes {
            attribute(myUsage, project.objects.named(Usage, 'my-value'))
        }
    }
}
// end::named-attributes[]
