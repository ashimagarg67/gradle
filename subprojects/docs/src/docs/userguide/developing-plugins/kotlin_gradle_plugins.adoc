= Writing Gradle plugins in Kotlin

In addition to <<kotlin_dsl.adoc, writing build scripts>>, Gradle also supports writing plugins in https://www.jetbrains.com/opensource/kotlin/[Kotlin].

There are multiple options to write your Kotlin plugins and multiple compatibility considerations.
This page includes a non-exhaustive list of dependencies and compiler configurations, and explores their impact on compatibility and usability.

It also describes the different development plugins that you can use to set up these different options.


[[sec:dependencies]]
== Different dependencies

Like other JVM projects, Gradle plugins are JAR files with dependencies.
However,  unlike other JVM projects, Gradle provides fixed versions of some dependencies at runtime.
Those dependencies are `compileOnly` dependencies and need to be compatible with the version of Gradle your plugin is running in.

If you are writing convention plugins, this is typically not an issue.
However, if you distribute your plugins, you should pay particular attention to their compatibility.

[[sec:gradle_api]]
=== The Gradle API

All plugins use the https://docs.gradle.org/current/javadoc/index.html[Gradle Core API] to configure a Gradle build.
The Gradle API must be added as a build compile-time dependency using the helper function `gradleApi()`

[source,kotlin]
----
dependencies {
    compileOnly(gradleApi())
}
----

TIP: `gradleApi()` must be a `compileOnly` dependency, because the correct Gradle API will be provided by Gradle at runtime.

==== Version of the Gradle API Version

The Gradle API version provided by `gradleApi()` is the same as the version of Gradle used to build the plugin.

For example, if the plugin is built using Gradle version 7.6.1, then `gradleApi()` will also be version 7.6.1.
If the plugin is later built with Gradle {gradleVersion}, then the `gradleApi()` will change to version {gradleVersion}.

This implicit link affects the Gradle versions your plugin supports.
It's easy to build a plugin using one version of Gradle that has functions or classes that are not present in other versions of Gradle.

If a plugin uses the functionality of the Gradle API that is missing in the Gradle being used to run the plugin, it might result in a runtime exception, such as `NoSuchMethodError`.
This can happen if the plugin is run by an older Gradle version that is missing a function or class.
It can also happen if the plugin uses a function or class that has been removed in newer versions (which can happen when using deprecated or internal Gradle features).

Supporting different versions of Gradle can be tested using https://docs.gradle.org/current/userguide/test_kit.html#sub:gradle-runner-gradle-version[TestKit].

[[sec:redistributed_gradle_api]]
=== Redistributed Gradle API

To avoid the implicit link on a Gradle version that comes with using `gradleApi()`, you can use the https://docs.nokee.dev/manual/gradle-plugin-development.html[Nokee redistributed Gradle API artifacts].
These are like `gradleApi()`, except they allow specifying a specific version of the Gradle API:

[subs="attributes"]
[source,kotlin]
----
dependencies {
    compileOnly("dev.gradleplugins:gradle-api:{gradleVersion}")
}
----

TIP: Because it is provided by Gradle at runtime, `gradle-api` must be a `compileOnly` dependency.

This makes the version of the Gradle API being used to build the plugin more explicit.
Removing the ambiguity avoids the implicit link between `gradleApi()` and the build version of Gradle.

On the other hand, you cannot use newer APIs if your plugin is running on a recent version of Gradle.

[[sec:gradle_kotlin_dsl]]
=== gradleKotlinDsl()

[source,kotlin]
----
dependencies {
    compileOnly(gradleKotlinDsl())
}
----

The `gradleKotlinDsl()` contains helpers to work better with Kotlin.

For example:

* `tasks.withType<Jar> {}` (instead of `tasks.withType(Jar::class.java) {}`)
* `val commonMain by getting {}` (instead of `getByName("commonMain") {}`)
* `"implementation"("group:artifact:version")` (instead of `add("implementation", "group:artifact:version")`)
* Even `gradleKotlinDsl()` is provided by `gradleKotlinDsl()` !

You can optionally use it to build your plugins.

It is part of the Gradle distribution, which you will find under `~/.gradle/wrapper/dists/gradle-$version-bin/$sha/gradle-$version/lib/gradle-kotlin-dsl-$version.jar`.

When writing `build.gradle.kts`, `gradleKotlinDsl()` is in the classpath and provides helpers to work better with Kotlin.

TIP: Because it is provided by Gradle at runtime, `gradleKotlinDsl()` must be a `compileOnly` dependency.

[[sec:kotlin_stdlib]]
=== kotlin-stdlib

[source,kotlin]
----
dependencies {
    compileOnly("org.jetbrains.kotlin:kotlin-stdlib:$version")
}
----

The Kotlin compatibility matrix can be found in the https://docs.gradle.org/current/userguide/compatibility.html#kotlin[Gradle compatibility page].
If you want your plugin to be compatible with a given version of Gradle, you must use a compatible version of kotlin-stdlib.
For example, if you need your plugin to be compatible with Gradle 7.0, you cannot use the Kotlin 1.5 API (such as https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/lowercase.htmllowercase).
You need to compile against `kotlin-stdlib:1.4.31`.

[source,kotlin]
----
dependencies {
    compileOnly("org.jetbrains.kotlin:kotlin-stdlib:1.4.31")
}
----

For similar reasons, any transitive dependency of your plugin must use a `kotlin-stdlib` version compatible with the Gradle one.
While you can ensure that at compile time for your code, it's often more complicated for dependencies,.
So test your plugins and/or double-check your transitive dependencies.

Note: The `kotlin-stdlib` version is independent of your Kotlin Gradle Plugin version.
You can use a newer Kotlin Gradle Plugin version with an older `kotlin-stdlib` using the https://kotlinlang.org/docs/compiler-reference.html#api-version-version[`apiVersion`] compiler argument.

TIP: Because it is provided by Gradle at runtime, `kotlin-stdlib` must be a `compileOnly` dependency.

[[sec:kotlin_reflect]]
=== kotlin-reflect

[source,kotlin]
----
dependencies {
    compileOnly("org.jetbrains.kotlin:kotlin-reflect:$version")
}
----

Not all plugins need `kotlin-reflect` but if yours does, the situation is the same as for `kotlin-stdlib`.
`kotlin-reflect` needs to be compatible with the https://docs.gradle.org/current/userguide/compatibility.html#kotlin[target Gradle version].

TIP: Because it is provided by Gradle at runtime, `gradle-api` must be a `compileOnly` dependency.

[[sec:others]]
=== others (`implementation` or `api`)

You can add other non-compileOnly dependencies:

[source,kotlin]
----
dependencies {
    // Kotlin dependencies
    // ⚠️ make sure they do not depend on an incompatible version of kotlin-stdlib
    implementation("com.squareup:kotlinpoet:1.12.0")

    // Java dependencies
    implementation("asm:asm:3.3.1")
}
----

Gradle does not provide these dependencies at runtime and should use the `implementation` configuration (or `api` if part of your plugin API).
Because Gradle may load different plugins with conflicting dependencies in the same https://dev.to/autonomousapps/build-compile-run-a-crash-course-in-classpaths-f4g[classloader], your plugin users may experience crashes if symbols are incompatible or missing.
To mitigate this, you can relocate your dependencies.

[[sec:compiler_options]]
== Different compiler configurations

You can choose different options to either improve the developer experience of writing plugins and/or improve compatibility with Gradle and Java in general.

[[sec:sam_with_receiver]]
=== `sam-with-receiver` compiler plugin

Gradle comes with the https://docs.gradle.org/current/javadoc/org/gradle/api/HasImplicitReceiver.html[@HasImplicitReceiver] annotation.
When used in conjunction with Kotlin https://kotlinlang.org/docs/sam-with-receiver-plugin.html[sam-with-receiver compiler plugin], it can turn the parameter of https://kotlinlang.org/docs/fun-interfaces.html[Single Abstract Method (SAM)] interfaces like https://docs.gradle.org/current/javadoc/org/gradle/api/Action.html[Action] into implicit receiver making your code look more like a DSL:

[source,kotlin]
----
// Without sam-with-receiver
tasks.register("hello") { task ->
    // You need to use the lambda parameter
    task.doLast {
        println("Hello World")
    }
}

// With sam-with-receiver
tasks.register("hello") {
    // You can use the receiver
    doLast {
        println("Hello World")
    }
}
----

The latter looks closer to `build.gradle.kts` scripts and is more concise but is prone to scoping errors as well.


[[sec:kotlin_assignment]]
=== `kotlin-assignment` compiler plugin

The https://plugins.gradle.org/plugin/org.jetbrains.kotlin.plugin.assignment/1.8.20[`kotlin-assignment` compiler plugin] allows overriding assignments so that Kotlin callers do not have to call `.set()` on https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Property.html[Property]:


----
// Without kotlin-asignment
tasks.jar.configure {
    // You need to call .set()
    archiveBaseName.set("mylib")
}

// With kotlin-asignment
tasks.jar.configure {
    // No need to call .set()
    archiveBaseName = "mylib"
}
----

[[sec:api_version]]
=== `apiVersion` compiler option

The https://kotlinlang.org/docs/compiler-reference.html#api-version-version[Kotlin compiler apiVersion option] enforces the generated bytecode to use declaration from the given version only.
This is important to stay compatible with the Kotlin version embedded by Gradle.

Note: while this enforces your code is compatible with a given version of Kotlin stdlib and Gradle, it does not check dependencies, so it is important to check your dependencies are also compatible.

[[sec:sam_conversion_class]]
=== `-Xsam-conversions=class` compiler option

`-Xsam-conversions=class` sets up the implementation strategy for SAM (single abstract method) conversion to always generate anonymous classes, instead of using the `invokedynamic` JVM instruction.
This is to make sure the lambdas are serializable and provide better support for configuration cache and incremental build.
This is particularly important for lambdas used from `doLast`:
See https://github.com/gradle/gradle/issues/17052[Issue #17052] for more information.

[source,kotlin]
----
// Without `-Xsam-conversions=class` task will never be up-to-date
task.doLast {
    // Something
}
----


[[sec:plugins_for_your_plugins]]
== Different development plugins

In order to configure all the above options and more, Gradle offers several plugins:

* `"java-gradle-plugin"`
* `"org.jetbrains.kotlin.jvm"` (also used as `kotlin("jvm")`)
* `"org.gradle.kotlin.embedded-kotlin"` (also used as `&#96;embedded-kotlin&#96;`))
* `"org.gradle.kotlin.kotlin-dsl"` (also used as `&#96;kotlin-dsl&#96;`)

Usually you would choose one of those combinations:

* `"java-gradle-plugin"` and `"org.jetbrains.kotlin.jvm"`
* `"java-gradle-plugin"` and `&#96;embedded-kotlin&#96;`
* `&#96;kotlin-dsl&#96;`

Let's see what each plugin is doing.

[[sec:java_gradle_plugin]]
=== The `"java-gradle-plugin"` plugin (built-in)

`"java-gradle-plugin"` amongst other things:

* applies the <<java_library_plugin.adoc#java_library_plugin,Java Library (`java-library`)>> plugin
* adds the `gradlePlugin {}` extension and generates the resource files matching your plugin id with its implementation class
* adds the `gradleApi()` dependency to the `api` configuration
* performs validation of plugin metadata during `jar` task execution.
* adds the `gradleTestKit()` dependency to the `testImplementation` configuration

You always want this plugin to develop custom Gradle plugins (although other plugins might apply it for you).
Refer to the full <<java_gradle_plugin.adoc, documentation>> for more information.

[[sec:kotlin_jvm]]
=== The `"org.jetbrains.kotlin.jvm"` plugin

`"org.jetbrains.kotlin.jvm"` is the plugin configuring the Kotlin compiler, amongst many other things.

You usually always want this plugin to develop custom Gradle plugins (although other plugins might apply it for you).
Refer to the full https://kotlinlang.org/docs/gradle.html[documentation] for more information.

[[sec:embedded-kotlin]]
=== The `&#96;embedded-kotlin&#96;` plugin

[source,kotlin]
----
plugins {
  `embedded-kotlin`
}
----

`&#96;embedded-kotlin&#96;` is built on top of `"org.jetbrains.kotlin.jvm"` and does the following:

* applies the `"org.jetbrains.kotlin.jvm"` plugin using the same version as the Gradle embedded version
* adds `kotlin-stdlib` and `kotlin-reflect` to the `compileOnly` dependency

Use this plugin if you want to use the same Kotlin version to develop your plugins that the version used by your Gradle build.
This is especially useful if you do not intend to distribute your plugins (i.e. convention plugins).

[[sec:kotlin-dsl]]
=== The `&#96;kotlin-dsl&#96;` plugin

[source,kotlin]
----
plugins {
  `kotlin-dsl`
}
----

`&#96;kotlin-dsl&#96;` is built on top of `&#96;embedded-kotlin&#96;` and does the following:

* applies `"java-gradle-plugin"`
* applies `kotlin-embedded`
* applies the `&#96;kotlin-dsl-precompiled-script-plugins&#96;` allowing to use `build.gradle.kts` files
* adds `gradleKotlinDsl()` to the `compileOnly` configuration
* configures the `sam-with-receiver` Kotlin compiler plugin
* configures the `kotlin-assignment` Kotlin compiler plugin
* sets `apiVersion` and `languageVersion` to the Kotlin embedded version
* adds the `-Xsam-conversions=class` compiler option
* adds others compiler options for compatibility:
** `-java-parameters` to support https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html[Java 8 Parameter] class and getting method parameters through reflection
** `-Xjvm-default=all` to add link:https://kotlinlang.org/docs/java-to-kotlin-interop.html#default-methods-in-interfaces[Default methods in interfaces]
** `-Xjsr305=strict` for https://kotlinlang.org/docs/java-interop.html#compiler-configuration[increased null safety]


The `&#96;kotlin-dsl&#96;` plugin is an all-in-one plugin.
By applying the `&#96;kotlin-dsl-precompiled-script-plugins&#96;` and the same options as Gradle when compiling scripts, it allows you to write plugins using the `.gradle.kts` file.

Like the `&#96;embedded-kotlin&#96;` plugin, it uses the same Kotlin version as your Gradle build.
This is useful if you do not intend to distribute your plugins (i.e. convention plugins).
If you need to distribute your plugin, make sure to use a Kotlin version that is compatible with the Gradle version you are targeting.


[[sec:your_public_api]]
== Plugin API compatibility

In order to make your plugin API compatible with Groovy, avoid relying on Kotlin specific features so that the developer experience is as good for Groovy scripts as it is for Kotlin scripts.
For example, the Kotlin compiler emits https://github.com/JetBrains/kotlin/blob/master/libraries/kotlinx-metadata/jvm/ReadMe.md[metadata] that only the Kotlin compiler can understand for features like default parameters or extension function.
It is OK to use those to provide a better experience for Kotlin scripts as long as the same functionality is accessible through other means in Groovy.

In general, relying on link:{kotlin-reference}java-interop.html[calling Java from Kotlin recommendations] and link:{kotlin-reference}java-to-kotlin-interop.html[calling Kotlin from Java recommendations] works well for Groovy too.

[[sec:action]]
`Action`

Do not use Kotlin function types in your API. Groovy doesn't know about anything about Kotlin function types. Groovy uses Closures.

Instead, use an `Action<T>` parameter. Decorated Gradle objects contain an overload for every function that takes an `Action<T>` parameter:

[source,kotlin]
----
class Something

abstract class MyExtension {
    // Use Action<T> in your APIs
    // Gradle will generate an overload at runtime that takes a Groovy Closure
    fun doSomething(action: Action<Something>) {
        //
    }
}
----

For the overload to be generated,/ the object must be constructed by Gradle. For example:

[source,kotlin]
----
abstract class MyPlugin: Plugin<Project> {
  override fun apply(project: Project) {
    project.extensions.create("myExtension", MyExtension::class.java)
  }
}
----
